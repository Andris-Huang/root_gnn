#!/usr/bin/env python 
import os

import tensorflow as tf
import numpy as np
import sklearn.metrics

import matplotlib.pyplot as plt

from root_gnn.src.datasets import graph
from root_gnn.src.datasets import herwig_hadrons as hhdata
from root_gnn.src.models import model_utils

from root_gnn import utils_plot

ckpt_name = 'checkpoint'

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Calculate the metrics for jet reco.')
    add_arg = parser.add_argument
    add_arg("filenames", help="input event files in TFRec format")
    add_arg("config", help="configuration file used for training")
    add_arg("outname", help='output name prefix')
    add_arg("--nevts", default=-1, help='number of events', type=int)
    args = parser.parse_args()

    outname = args.outname

    if not os.path.exists(args.config):
        print("{} does not exists", args.config)

    # ploting and labeling info
    properties = ['E', 'px', 'py', 'pz']
    ppt = "(${0}$ - ${0}_\mathrm{{truth}}$) / ${0}_\mathrm{{truth}}$"
    diff_labels = [ppt.format(x) for x in properties]
    figstyle = {
        "alpha": 1.0,
        'histtype': 'step',
        'lw': 2,
    }

    # load data
    filenames = tf.io.gfile.glob(args.filenames)
    AUTO = tf.data.experimental.AUTOTUNE
    dataset = tf.data.TFRecordDataset(filenames)
    dataset = dataset.map(graph.parse_tfrec_function, num_parallel_calls=AUTO)
    nevts = sum([1 for _ in dataset])
    print("{} files and {:,} events".format(len(filenames), nevts))
    print("maximum {} nodes in one graph".format(hhdata.max_nodes)) 

    model, _, _ = model_utils.create_load_model(args.config)
    num_processing_steps = hhdata.max_nodes

    node_preds = [] # node prediction
    node_props = [] # node properties
    truth_node_pred = []
    truth_node_prop = []

    ievt = 0  
    for event in dataset:
        if args.nevts > 0 and ievt >= args.nevts:
            break

        inputs, targets = event
        node_pred, global_pred = model(inputs, num_processing_steps)
        global_pred = tf.squeeze(tf.concat(global_pred, axis=-1))

        # print("node properties", node_pred)
        # print("to add a node", global_pred)


        node_preds.append(global_pred)
        node_props.append(node_pred)
        truth_node_pred.append(tf.squeeze(targets.globals).numpy())
        truth_node_prop.append(tf.concat([targets.nodes[1:, :],\
            tf.zeros([1, targets.nodes.shape[1]])], axis=0).numpy())
        ievt += 1


    for istep in range(num_processing_steps):
        istep = 0
        inode_preds = np.array([x[istep] for x in node_preds])
        # node_prop = np.concatenate(node_prop, axis=0)
        truth_inode_pred = np.array([x[istep] for x in truth_node_pred])
        # truth_node_prop = np.concatenate(truth_node_prop, axis=0)
        
        # node predictions
        threshold = 0.5
        pred_y_true, _ = (truth_inode_pred > threshold), (inode_preds > threshold)
        pred_fpr, pred_tpr, _ = sklearn.metrics.roc_curve(pred_y_true, inode_preds)
        pred_auc = sklearn.metrics.auc(pred_fpr, pred_tpr)
        print("AUC: {:0.4f}".format(pred_auc))
        utils_plot.plot_metrics(inode_preds, truth_inode_pred,
                            outname="{}_node_{}_preds.pdf".format(outname, istep),
                            true_label="Add",
                            fake_label="Stop",
                            y_label="Nodes",
                            x_label='Node score',
                            eff_purity_label="Threshold on node score",
                            )

        for iprop,propname in enumerate(properties):
            inode_props = np.array([x[istep][iprop] for x in node_props])
            inode_props_truth = np.array([x[istep][iprop] for x in truth_node_prop])
            diff = (inode_props - inode_props_truth) / inode_props_truth

            _, ax = plt.subplots(1, 1, figsize=(5,5), constrained_layout=True)
            _, _, patches = ax.hist(diff, bins=100, range=(-3, 3), **figstyle)
            ax.set_xlabel(diff_labels[iprop])
            ax.set_ylabel("Events")
            plt.savefig("{}_node_{}_prop_{}.pdf".format(outname, istep, propname))
            plt.clf()